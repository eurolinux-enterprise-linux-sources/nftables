From 8a8b80fafcbf3843e1736daff707b7cb5b64f31f Mon Sep 17 00:00:00 2001
From: Phil Sutter <psutter@redhat.com>
Date: Wed, 20 Jun 2018 09:22:00 +0200
Subject: [PATCH] Review switch statements for unmarked fall through cases

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1504157
Upstream Status: nftables commit 7f31d3191622b

commit 7f31d3191622b650521014e311ace96aa7c5522c
Author: Phil Sutter <phil@nwl.cc>
Date:   Wed Feb 28 16:06:16 2018 +0100

    Review switch statements for unmarked fall through cases

    While revisiting all of them, clear a few oddities as well:

    - There's no point in marking empty fall through cases: They are easy to
      spot and a common concept when using switch().

    - Fix indenting of break statement in one occasion.

    - Drop needless braces around one case which doesn't declare variables.

    Signed-off-by: Phil Sutter <phil@nwl.cc>
    Signed-off-by: Florian Westphal <fw@strlen.de>
---
 src/ct.c                  | 2 +-
 src/evaluate.c            | 1 +
 src/hash.c                | 2 +-
 src/netlink_delinearize.c | 1 +
 src/rule.c                | 5 +++--
 5 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/src/ct.c b/src/ct.c
index 8ab32e9..1e06013 100644
--- a/src/ct.c
+++ b/src/ct.c
@@ -289,7 +289,7 @@ static void ct_print(enum nft_ct_keys key, int8_t dir, uint8_t nfproto,
 	}
 
 	switch (key) {
-	case NFT_CT_SRC: /* fallthrough */
+	case NFT_CT_SRC:
 	case NFT_CT_DST:
 		desc = proto_find_upper(&proto_inet, nfproto);
 		if (desc)
diff --git a/src/evaluate.c b/src/evaluate.c
index f16bb33..25a7376 100644
--- a/src/evaluate.c
+++ b/src/evaluate.c
@@ -2705,6 +2705,7 @@ static int stmt_evaluate_objref_map(struct eval_ctx *ctx, struct stmt *stmt)
 
 		map->mappings->set->flags |=
 			map->mappings->set->init->set_flags;
+		/* fall through */
 	case EXPR_SYMBOL:
 		if (expr_evaluate(ctx, &map->mappings) < 0)
 			return -1;
diff --git a/src/hash.c b/src/hash.c
index 9cd3c8c..3355cad 100644
--- a/src/hash.c
+++ b/src/hash.c
@@ -20,7 +20,7 @@ static void hash_expr_print(const struct expr *expr, struct output_ctx *octx)
 	switch (expr->hash.type) {
 	case NFT_HASH_SYM:
 		nft_print(octx, "symhash");
-	break;
+		break;
 	case NFT_HASH_JENKINS:
 	default:
 		nft_print(octx, "jhash ");
diff --git a/src/netlink_delinearize.c b/src/netlink_delinearize.c
index 11fd330..61cba52 100644
--- a/src/netlink_delinearize.c
+++ b/src/netlink_delinearize.c
@@ -1411,6 +1411,7 @@ static void ct_meta_common_postprocess(struct rule_pp_ctx *ctx,
 	case OP_NEQ:
 		if (right->ops->type != EXPR_SET && right->ops->type != EXPR_SET_REF)
 			break;
+		/* fall through */
 	case OP_LOOKUP:
 		expr_set_type(right, left->dtype, left->byteorder);
 		break;
diff --git a/src/rule.c b/src/rule.c
index d744cf6..e7ccb2b 100644
--- a/src/rule.c
+++ b/src/rule.c
@@ -1297,7 +1297,7 @@ static void obj_print_data(const struct obj *obj,
 		}
 		}
 		break;
-	case NFT_OBJECT_CT_HELPER: {
+	case NFT_OBJECT_CT_HELPER:
 		nft_print(octx, "ct helper %s {\n", obj->handle.obj);
 		nft_print(octx, "\t\ttype \"%s\" protocol ",
 			  obj->ct_helper.name);
@@ -1305,7 +1305,6 @@ static void obj_print_data(const struct obj *obj,
 		nft_print(octx, "\t\tl3proto %s",
 			  family2str(obj->ct_helper.l3proto));
 		break;
-		}
 	case NFT_OBJECT_LIMIT: {
 		bool inv = obj->limit.flags & NFT_LIMIT_F_INV;
 		const char *data_unit;
@@ -1617,11 +1616,13 @@ static int do_command_reset(struct netlink_ctx *ctx, struct cmd *cmd)
 	switch (cmd->obj) {
 	case CMD_OBJ_COUNTERS:
 		dump = true;
+		/* fall through */
 	case CMD_OBJ_COUNTER:
 		type = NFT_OBJECT_COUNTER;
 		break;
 	case CMD_OBJ_QUOTAS:
 		dump = true;
+		/* fall through */
 	case CMD_OBJ_QUOTA:
 		type = NFT_OBJECT_QUOTA;
 		break;
-- 
1.8.3.1

